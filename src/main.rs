use std::fmt::{Display, Formatter};

use inquire::{error::InquireResult, validator::Validation, CustomType, Select, Text};

struct Produce {
    name: String,
    price: f64,
}

fn add_produce(mut list: Vec<Produce>) -> InquireResult<Vec<Produce>> {
    let name = Text::new("Enter produce name: ").prompt()?;
    let price = CustomType::<f64>::new("How much did it cost?")
        .with_formatter(&|i| format!("{:.2} PLN", i))
        .with_error_message("Please type a valid number")
        .with_validator(|val: &f64| {
            if *val >= 0.0f64 {
                return Ok(Validation::Valid);
            }
            return Ok(Validation::Invalid("You must enter positive amount".into()));
        })
        .prompt()?;
    list.push(Produce { name, price });

    Ok(list)
}

#[derive(Debug, Clone)]
enum MenuOption {
    AddProduce,
    PrintList,
    Exit,
}
impl MenuOption {
    // could be generated by macro
    const VARIANTS: &'static [MenuOption] = &[Self::AddProduce, Self::PrintList, Self::Exit];
}

impl Display for MenuOption {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "{:?}", self)
    }
}

fn main() -> InquireResult<()> {
    let mut list: Vec<Produce> = vec![];
    loop {
        let ans: MenuOption = Select::new("Choice", MenuOption::VARIANTS.to_vec()).prompt()?;
        match ans {
            MenuOption::AddProduce => list = add_produce(list)?,
            MenuOption::PrintList => {
                for p in &list {
                    println!("{} {:.2} PLN", p.name, p.price)
                }
            }
            MenuOption::Exit => return Ok(()),
        }
    }
}

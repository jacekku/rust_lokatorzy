use std::{
    fmt::{Display, Formatter},
    vec,
};

use inquire::{error::InquireResult, validator::Validation, CustomType, Select, Text};

struct Person {
    name: String,
    produce: Vec<Product>,
}
struct Product {
    name: String,
    price: f64,
}
#[derive(Debug, Clone)]
enum MenuOption {
    AddProduce,
    PrintList,
    Exit,
}
impl MenuOption {
    // could be generated by macro
    const VARIANTS: &'static [MenuOption] = &[Self::AddProduce, Self::PrintList, Self::Exit];
}

impl Display for MenuOption {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "{:?}", self)
    }
}

fn add_product(person: &mut Person) -> Result<(), inquire::InquireError> {
    println!("Person found with name {}", person.name);
    let name = Text::new("Enter produce name: ").prompt()?;
    let price = CustomType::<f64>::new("How much did it cost?")
        .with_formatter(&|i| format!("{:.2} PLN", i))
        .with_error_message("Please type a valid number")
        .with_validator(|val: &f64| {
            if *val >= 0.0f64 {
                return Ok(Validation::Valid);
            }
            return Ok(Validation::Invalid("You must enter positive amount".into()));
        })
        .prompt()?;
    person.produce.push(Product { name, price });
    Ok(())
}

fn print_list(list: &Vec<Person>) {
    for person in list {
        println!("{}", person.name);
        for product in person.produce.iter() {
            println!(" - {} {:.2} PLN", product.name, product.price)
        }
        println!(
            "  Total: {:.2} PLN",
            person
                .produce
                .iter()
                .map(|e| e.price)
                .reduce(|acc, e| acc + e)
                .unwrap_or(0.0f64)
        )
    }
}
// {
// fn result_demo(value: String) -> Result<bool, String> {
//     if value == "Cośtam".to_string() {
//         return Ok(true);
//     }
//     return Err("Coś jebło cnie".to_string());
// }
// fn some_fn() -> Result<bool, String> {
//     let is_cos_tam = result_demo("not cośtam".to_string())?;
//     println!("jest Cośtam");
//     return Ok(is_cos_tam);
// }
// fn wyzsza_funkcja() {
//     let value: String;
//     let result = some_fn();
//     println!("{value}");
//     match result {
//         Ok(_) => todo!(),
//         Err(_) => todo!(),
//     }
// }
// }
fn main() -> InquireResult<()> {
    let mut person_list: Vec<Person> = vec![];

    person_list.push(Person {
        name: "Jacek".to_string(),
        produce: vec![],
    });
    person_list.push(Person {
        name: "Magda".to_string(),
        produce: vec![],
    });

    loop {
        let ans: MenuOption = Select::new("Choice", MenuOption::VARIANTS.to_vec()).prompt()?;
        match ans {
            MenuOption::AddProduce => {
                if person_list.len() == 0 {
                    println!("No person added to list, please add one to continue");
                    continue;
                }
                let person_name =
                    Select::new("", person_list.iter().map(|p| p.name.clone()).collect())
                        .prompt()?;

                let _predicate = |p: &&Person| p.name.eq(&person_name.clone());
                // let person_option = person_list.iter_mut().find(|p| p.name.contains("Jacek"));

                let mut person_option: Option<&mut Person>;
                {
                    person_option = None;
                    for p in person_list.iter_mut() {
                        if p.name.eq(&person_name.clone()) {
                            person_option = Some(p);
                            break;
                        }
                    }
                }
                match person_option {
                    Some(person) => add_product(person)?,
                    None => println!("No person found with that name"),
                }
            }
            MenuOption::PrintList => print_list(&person_list),
            MenuOption::Exit => return Ok(()),
        }
    }
}

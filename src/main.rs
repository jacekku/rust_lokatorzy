use std::{
    fmt::{Display, Formatter},
    vec,
};

use inquire::{error::InquireResult, validator::Validation, CustomType, Select, Text};

struct Produce {
    name: String,
    price: f64,
}
#[derive(Debug, Clone)]
enum MenuOption {
    AddProduce,
    PrintList,
    Exit,
}
impl MenuOption {
    // could be generated by macro
    const VARIANTS: &'static [MenuOption] = &[Self::AddProduce, Self::PrintList, Self::Exit];
}

impl Display for MenuOption {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "{:?}", self)
    }
}

fn add_produce(mut list: Vec<Produce>) -> InquireResult<Vec<Produce>> {
    let name = Text::new("Enter produce name: ").prompt()?;
    let price = CustomType::<f64>::new("How much did it cost?")
        .with_formatter(&|i| format!("{:.2} PLN", i))
        .with_error_message("Please type a valid number")
        .with_validator(|val: &f64| {
            if *val >= 0.0f64 {
                return Ok(Validation::Valid);
            }
            return Ok(Validation::Invalid("You must enter positive amount".into()));
        })
        .prompt()?;
    list.push(Produce { name, price });

    Ok(list)
}
fn print_list(list: &Vec<Produce>) {
    for p in list {
        println!("{} {:.2} PLN", p.name, p.price)
    }
    println!(
        "Total: {:.2} PLN",
        list.iter()
            .map(|e| e.price)
            .reduce(|acc, e| acc + e)
            .unwrap_or(0.0f64)
    )
}

fn main() -> InquireResult<()> {
    let mut produce_list: Vec<Produce> = vec![];

    loop {
        let ans: MenuOption = Select::new("Choice", MenuOption::VARIANTS.to_vec()).prompt()?;
        match ans {
            MenuOption::AddProduce => produce_list = add_produce(produce_list)?,
            MenuOption::PrintList => print_list(&produce_list),
            MenuOption::Exit => return Ok(()),
        }
    }
}
